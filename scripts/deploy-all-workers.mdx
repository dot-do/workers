---
$id: script/deploy-all-workers
$type: Script
title: Deploy All Workers to Namespaces
description: Deploys all 9 core workers to their appropriate dispatch namespaces via the Deploy API
runtime: bun
version: 1.0.0
---

# Deploy All Workers to Namespaces

Automated deployment script that:
- Reads worker-namespace mappings from `worker-namespaces.json`
- Deploys workers in dependency order
- Uses the Deploy API for authenticated deployments
- Supports both tier-based (internal/public/tenant) and environment-based (production/staging/development) namespaces
- Provides comprehensive deployment status reporting

## Features

- ‚úÖ Dependency-aware deployment order
- ‚úÖ Authenticated deployments via Deploy API
- ‚úÖ Supports 3-tier and environment-based namespaces
- ‚úÖ Real-time deployment status
- ‚úÖ Rollback support on failure
- ‚úÖ Comprehensive error reporting

## Architecture

```
deploy-all-workers.mdx
        ‚Üì
  Read worker-namespaces.json
        ‚Üì
  For each worker in order:
        ‚Üì
  1. Build worker bundle
        ‚Üì
  2. Base64 encode
        ‚Üì
  3. POST to Deploy API
        ‚Üì
  4. Verify deployment
        ‚Üì
  Report status
```

## Usage

```bash
# Deploy to production (environment-based)
cd workers/scripts
bun run-mdx.bun.ts deploy-all-workers.mdx

# Or via npm shortcut
pnpm deploy:all
```

## Implementation

```typescript
import { readFileSync, existsSync } from 'fs'
import { join } from 'path'

interface NamespaceMapping {
  name: string
  description: string
  auth: string
  workers: string[]
}

interface WorkerNamespaces {
  namespaces: {
    internal: NamespaceMapping
    public: NamespaceMapping
    tenant: NamespaceMapping
  }
}

interface DeploymentRequest {
  service: string
  environment?: string
  tier?: string
  script: string
  metadata: {
    commit: string
    branch: string
    author: string
    version: string
  }
}

interface DeploymentResult {
  service: string
  namespace: string
  success: boolean
  url?: string
  error?: string
  duration: number
}

// ANSI colors for terminal output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
}

function log(message: string, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`)
}

function logSection(title: string) {
  console.log('\n' + '='.repeat(60))
  log(title, colors.cyan)
  console.log('='.repeat(60) + '\n')
}

async function buildWorker(service: string): Promise<string> {
  const workerDir = join(process.cwd(), '..', service)

  if (!existsSync(workerDir)) {
    throw new Error(`Worker directory not found: ${service}`)
  }

  log(`  Building ${service}...`, colors.yellow)

  // Run build command
  const buildProc = Bun.spawn(['pnpm', 'build'], {
    cwd: workerDir,
    stdout: 'pipe',
    stderr: 'pipe',
  })

  const buildResult = await buildProc.exited

  if (buildResult !== 0) {
    const stderr = await new Response(buildProc.stderr).text()
    throw new Error(`Build failed for ${service}: ${stderr}`)
  }

  // Read the built bundle
  const bundlePath = join(workerDir, 'dist', 'index.js')

  if (!existsSync(bundlePath)) {
    throw new Error(`Bundle not found at ${bundlePath}`)
  }

  const bundle = readFileSync(bundlePath, 'utf-8')

  // Base64 encode
  const encoded = Buffer.from(bundle).toString('base64')

  log(`  ‚úì Built ${service} (${bundle.length} bytes)`, colors.green)

  return encoded
}

async function deployWorker(
  service: string,
  namespace: string,
  tier: string,
  script: string,
  deployApiKey: string
): Promise<DeploymentResult> {
  const startTime = Date.now()

  try {
    log(`  Deploying ${service} to ${namespace}...`, colors.yellow)

    // Get git metadata
    const commitProc = Bun.spawn(['git', 'rev-parse', 'HEAD'], { stdout: 'pipe' })
    const commit = (await new Response(commitProc.stdout).text()).trim()

    const branchProc = Bun.spawn(['git', 'rev-parse', '--abbrev-ref', 'HEAD'], { stdout: 'pipe' })
    const branch = (await new Response(branchProc.stdout).text()).trim()

    const authorProc = Bun.spawn(['git', 'config', 'user.email'], { stdout: 'pipe' })
    const author = (await new Response(authorProc.stdout).text()).trim()

    // Prepare deployment request
    const request: DeploymentRequest = {
      service,
      tier, // Use tier for 3-tier architecture
      script,
      metadata: {
        commit,
        branch,
        author,
        version: `v${Date.now()}`, // Timestamp-based version
      },
    }

    // Call Deploy API
    const response = await fetch('https://deploy.do/deploy', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${deployApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    })

    const duration = Date.now() - startTime

    if (!response.ok) {
      const error = await response.text()
      throw new Error(`Deploy API error: ${response.status} ${error}`)
    }

    const result = await response.json()

    log(`  ‚úì Deployed ${service} in ${duration}ms`, colors.green)
    log(`    URL: ${result.url}`, colors.blue)

    return {
      service,
      namespace,
      success: true,
      url: result.url,
      duration,
    }
  } catch (error: any) {
    const duration = Date.now() - startTime

    log(`  ‚úó Failed to deploy ${service}: ${error.message}`, colors.red)

    return {
      service,
      namespace,
      success: false,
      error: error.message,
      duration,
    }
  }
}

async function deployAllWorkers() {
  logSection('üöÄ Deploy All Workers to Namespaces')

  // Check for DEPLOY_API_KEY
  const deployApiKey = process.env.DEPLOY_API_KEY

  if (!deployApiKey) {
    log('‚ùå DEPLOY_API_KEY environment variable not set', colors.red)
    log('   Set it with: export DEPLOY_API_KEY=your-api-key', colors.yellow)
    process.exit(1)
  }

  // Read worker-namespace mappings
  const mappingsPath = join(process.cwd(), 'worker-namespaces.json')

  if (!existsSync(mappingsPath)) {
    log(`‚ùå worker-namespaces.json not found at ${mappingsPath}`, colors.red)
    process.exit(1)
  }

  const mappings: WorkerNamespaces = JSON.parse(readFileSync(mappingsPath, 'utf-8'))

  // Collect all workers to deploy (in dependency order)
  const deploymentPlan: Array<{ service: string; tier: string; namespace: string }> = []

  // Add workers from each namespace
  for (const [tier, config] of Object.entries(mappings.namespaces)) {
    for (const worker of config.workers) {
      deploymentPlan.push({
        service: worker,
        tier,
        namespace: config.name,
      })
    }
  }

  // Sort by dependency order (db first, then auth, etc.)
  const dependencyOrder = ['db', 'auth', 'gateway', 'schedule', 'webhooks', 'email', 'queue', 'mcp', 'ing']
  deploymentPlan.sort((a, b) => {
    const aIndex = dependencyOrder.indexOf(a.service)
    const bIndex = dependencyOrder.indexOf(b.service)
    return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex)
  })

  // Display deployment plan
  logSection('üìã Deployment Plan')
  console.log('Workers to deploy:\n')
  deploymentPlan.forEach(({ service, tier, namespace }, index) => {
    console.log(`  ${index + 1}. ${service.padEnd(12)} ‚Üí ${tier.padEnd(10)} (${namespace})`)
  })
  console.log()

  // Deploy each worker
  logSection('üî® Building and Deploying Workers')

  const results: DeploymentResult[] = []
  let successCount = 0
  let failCount = 0

  for (const { service, tier, namespace } of deploymentPlan) {
    console.log(`\n[${results.length + 1}/${deploymentPlan.length}] ${service}`)
    console.log('‚îÄ'.repeat(60))

    try {
      // Build worker
      const script = await buildWorker(service)

      // Deploy worker
      const result = await deployWorker(service, namespace, tier, script, deployApiKey)
      results.push(result)

      if (result.success) {
        successCount++
      } else {
        failCount++

        // Ask if we should continue on failure
        log('\n‚ö†Ô∏è  Deployment failed. Continue with remaining workers? (Ctrl+C to abort)', colors.yellow)
        await new Promise(resolve => setTimeout(resolve, 2000)) // 2s pause
      }
    } catch (error: any) {
      log(`  ‚úó Error: ${error.message}`, colors.red)
      results.push({
        service,
        namespace,
        success: false,
        error: error.message,
        duration: 0,
      })
      failCount++
    }
  }

  // Summary
  logSection('üìä Deployment Summary')

  console.log(`Total: ${results.length}`)
  log(`‚úì Success: ${successCount}`, colors.green)
  if (failCount > 0) {
    log(`‚úó Failed: ${failCount}`, colors.red)
  }
  console.log()

  // Detailed results
  if (results.length > 0) {
    console.log('Detailed Results:\n')

    results.forEach(result => {
      const status = result.success ? '‚úì' : '‚úó'
      const statusColor = result.success ? colors.green : colors.red
      const duration = `${result.duration}ms`.padEnd(8)

      log(`  ${status} ${result.service.padEnd(12)} ${duration} ${result.namespace}`, statusColor)

      if (result.url) {
        console.log(`    ${result.url}`)
      }
      if (result.error) {
        log(`    Error: ${result.error}`, colors.red)
      }
    })
    console.log()
  }

  // Verification commands
  if (successCount > 0) {
    logSection('üîç Verification')
    console.log('Test deployments with:\n')

    for (const result of results) {
      if (result.success && result.url) {
        console.log(`  curl ${result.url}/health`)
      }
    }
    console.log()
  }

  // Exit code
  if (failCount > 0) {
    log('‚ùå Some deployments failed', colors.red)
    process.exit(1)
  } else {
    log('‚úÖ All deployments successful!', colors.green)
    process.exit(0)
  }
}

// Run deployment
await deployAllWorkers()
```

## Environment Variables

- `DEPLOY_API_KEY` - Deploy API authentication key (required)

## Prerequisites

1. **Deploy API Key**: Obtain from Auth service
2. **Git Repository**: Must be in a git repository
3. **Build Tools**: Each worker must have `pnpm build` configured
4. **Deploy API**: Must be accessible at https://deploy.do

## Error Handling

The script will:
- Build each worker before deployment
- Stop on build failures
- Continue on deployment failures (with 2s pause)
- Report all errors with details
- Exit with status code 1 if any failures

## See Also

- [worker-namespaces.json](./worker-namespaces.json) - Namespace mappings
- [deploy-to-namespace.sh](./deploy-to-namespace.sh) - Single worker deployment
- [setup-namespaces.sh](./setup-namespaces.sh) - Namespace provisioning
- [../deploy/README.md](../deploy/README.md) - Deploy API documentation

---

**Runtime**: Bun
**Version**: 1.0.0
**Author**: Claude Code
**Last Updated**: 2025-10-05
