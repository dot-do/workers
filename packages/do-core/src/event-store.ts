/**
 * Event Store Implementation for Stream-Based Event Sourcing
 *
 * Provides stream-based event storage with:
 * - Monotonic versioning within streams
 * - Optimistic concurrency control via expectedVersion
 * - Causation and correlation tracking
 * - Pluggable serialization strategies
 * - Custom ID generation support
 * - Batch append operations
 *
 * @module event-store
 */

import type { SqlStorage } from './core.js'

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Event metadata for tracking causation and correlation.
 *
 * Metadata provides context for distributed tracing and event genealogy.
 * All fields are optional and custom fields can be added via index signature.
 *
 * @example
 * ```typescript
 * const metadata: EventMetadata = {
 *   causationId: 'evt-123',      // Event that caused this one
 *   correlationId: 'req-abc',    // Request correlation ID
 *   userId: 'user-456',          // User who triggered the event
 *   tenantId: 'tenant-789',      // Custom field
 * }
 * ```
 */
export interface EventMetadata {
  /** ID of the event that caused this event */
  causationId?: string
  /** Correlation ID for distributed tracing */
  correlationId?: string
  /** ID of the user who triggered this event */
  userId?: string
  /** Additional custom metadata */
  [key: string]: unknown
}

/**
 * Domain event structure for stream-based event sourcing.
 *
 * Events are immutable records of things that happened in the system.
 * They are stored in streams (identified by streamId) with monotonic versions.
 *
 * @typeParam T - The type of the event payload
 *
 * @example
 * ```typescript
 * const event: StreamDomainEvent<OrderPayload> = {
 *   id: 'evt-abc-123',
 *   streamId: 'order-456',
 *   type: 'OrderCreated',
 *   version: 1,
 *   timestamp: Date.now(),
 *   payload: { customerId: 'cust-789', total: 99.99 },
 * }
 * ```
 */
export interface StreamDomainEvent<T = unknown> {
  /** Unique event ID (generated by IdGenerator) */
  id: string
  /** Stream identifier (e.g., 'order-123', 'user-456') */
  streamId: string
  /** Event type (e.g., 'OrderCreated', 'ItemAdded') */
  type: string
  /** Event version within the stream (1, 2, 3, ...) */
  version: number
  /** Unix timestamp (ms) when event was recorded */
  timestamp: number
  /** Event payload data */
  payload: T
  /** Optional metadata for tracing and context */
  metadata?: EventMetadata
}

/**
 * Input for appending a new event to a stream.
 *
 * @typeParam T - The type of the event payload
 */
export interface AppendEventInput<T = unknown> {
  /** Stream identifier */
  streamId: string
  /** Event type */
  type: string
  /** Event payload */
  payload: T
  /** Expected version for optimistic concurrency control (0 for new streams) */
  expectedVersion?: number
  /** Optional metadata for tracing and context */
  metadata?: EventMetadata
}

/**
 * Input for batch appending multiple events to a stream.
 *
 * All events in a batch must belong to the same stream and are appended
 * atomically with sequential versions.
 *
 * @typeParam T - The type of the event payloads
 */
export interface AppendBatchInput<T = unknown> {
  /** Stream identifier (all events go to this stream) */
  streamId: string
  /** Expected version before batch append (0 for new streams) */
  expectedVersion?: number
  /** Events to append (in order) */
  events: Array<{
    /** Event type */
    type: string
    /** Event payload */
    payload: T
    /** Optional metadata for tracing and context */
    metadata?: EventMetadata
  }>
}

/**
 * Options for reading events from a stream.
 */
export interface ReadStreamOptions {
  /** Start reading from this version (inclusive, default: 1) */
  fromVersion?: number
  /** Read up to this version (inclusive) */
  toVersion?: number
  /** Maximum number of events to return */
  limit?: number
  /** Read in reverse order (newest first, default: false) */
  reverse?: boolean
}

/**
 * Result of appending a single event.
 */
export interface AppendResult {
  /** The appended event with generated ID and version */
  event: StreamDomainEvent
  /** Current stream version after append */
  currentVersion: number
}

/**
 * Result of batch appending multiple events.
 */
export interface AppendBatchResult {
  /** The appended events with generated IDs and versions */
  events: StreamDomainEvent[]
  /** Current stream version after batch append */
  currentVersion: number
}

// ============================================================================
// Serialization Hooks
// ============================================================================

/**
 * Event serializer interface for custom serialization strategies.
 *
 * Implement this interface to use custom serialization (e.g., MessagePack,
 * Protocol Buffers, or encrypted storage).
 *
 * @example
 * ```typescript
 * const encryptedSerializer: EventSerializer = {
 *   serialize: (data) => encrypt(JSON.stringify(data)),
 *   deserialize: (str) => JSON.parse(decrypt(str)),
 * }
 * ```
 */
export interface EventSerializer {
  /**
   * Serialize data to a string for storage.
   * @param data - The data to serialize
   * @returns Serialized string representation
   */
  serialize(data: unknown): string

  /**
   * Deserialize a string back to data.
   * @param str - The serialized string
   * @returns Deserialized data
   */
  deserialize(str: string): unknown
}

/**
 * Default JSON serializer implementation.
 *
 * Uses standard JSON.stringify/parse for serialization.
 * The deserialize method includes error handling for corrupted data.
 */
export const jsonSerializer: EventSerializer = {
  serialize: (data) => JSON.stringify(data),
  deserialize: (str) => {
    try {
      return JSON.parse(str)
    } catch (error) {
      console.error('Failed to deserialize JSON:', error)
      return null
    }
  },
}

// ============================================================================
// ID Generation Strategies
// ============================================================================

/**
 * ID generator function type.
 *
 * Implement custom ID generation strategies (UUID, ULID, nanoid, etc.)
 *
 * @returns A unique identifier string
 *
 * @example
 * ```typescript
 * // UUID generator (default)
 * const uuidGenerator: IdGenerator = () => crypto.randomUUID()
 *
 * // ULID generator (requires ulid package)
 * import { ulid } from 'ulid'
 * const ulidGenerator: IdGenerator = () => ulid()
 *
 * // Nanoid generator (requires nanoid package)
 * import { nanoid } from 'nanoid'
 * const nanoidGenerator: IdGenerator = () => nanoid()
 * ```
 */
export type IdGenerator = () => string

/**
 * Default UUID generator using crypto.randomUUID().
 */
export const uuidGenerator: IdGenerator = () => crypto.randomUUID()

// ============================================================================
// EventStore Options
// ============================================================================

/**
 * Configuration options for EventStore.
 *
 * Allows customization of ID generation, serialization, and other behaviors.
 *
 * @example
 * ```typescript
 * const options: EventStoreOptions = {
 *   idGenerator: () => ulid(),
 *   serializer: customSerializer,
 *   timestampProvider: () => Date.now(),
 * }
 *
 * const store = new EventStore(sql, options)
 * ```
 */
export interface EventStoreOptions {
  /**
   * Custom ID generator function.
   * @default crypto.randomUUID()
   */
  idGenerator?: IdGenerator

  /**
   * Custom serializer for payload and metadata.
   * @default JSON serializer
   */
  serializer?: EventSerializer

  /**
   * Custom timestamp provider function.
   * @default Date.now()
   */
  timestampProvider?: () => number
}

// ============================================================================
// IEventStore Interface
// ============================================================================

/**
 * Event Store interface for stream-based event sourcing.
 *
 * Defines the contract for event store implementations. The event store
 * provides stream-based storage with monotonic versioning, optimistic
 * concurrency control, and support for distributed tracing via metadata.
 *
 * @example
 * ```typescript
 * class CustomEventStore implements IEventStore {
 *   async append<T>(input: AppendEventInput<T>): Promise<AppendResult> {
 *     // Custom implementation
 *   }
 *   // ... other methods
 * }
 * ```
 */
export interface IEventStore {
  /**
   * Append a single event to a stream.
   *
   * @typeParam T - The type of the event payload
   * @param input - Event data to append
   * @returns The appended event and current stream version
   * @throws {ConcurrencyError} If expectedVersion doesn't match actual version
   *
   * @example
   * ```typescript
   * const result = await store.append({
   *   streamId: 'order-123',
   *   type: 'OrderCreated',
   *   payload: { customerId: 'cust-456' },
   *   expectedVersion: 0, // New stream
   * })
   * console.log(result.event.version) // 1
   * ```
   */
  append<T>(input: AppendEventInput<T>): Promise<AppendResult>

  /**
   * Append multiple events to a stream atomically.
   *
   * All events are appended in a single transaction with sequential versions.
   * If any event fails (e.g., concurrency conflict), no events are appended.
   *
   * @typeParam T - The type of the event payloads
   * @param input - Batch input with stream ID, expected version, and events
   * @returns The appended events and final stream version
   * @throws {ConcurrencyError} If expectedVersion doesn't match actual version
   *
   * @example
   * ```typescript
   * const result = await store.appendBatch({
   *   streamId: 'order-123',
   *   expectedVersion: 1,
   *   events: [
   *     { type: 'ItemAdded', payload: { itemId: 'item-1' } },
   *     { type: 'ItemAdded', payload: { itemId: 'item-2' } },
   *   ],
   * })
   * console.log(result.currentVersion) // 3
   * ```
   */
  appendBatch<T>(input: AppendBatchInput<T>): Promise<AppendBatchResult>

  /**
   * Read events from a stream.
   *
   * @param streamId - Stream identifier
   * @param options - Read options (fromVersion, toVersion, limit, reverse)
   * @returns Array of events in version order (or reverse if specified)
   *
   * @example
   * ```typescript
   * // Read all events
   * const events = await store.readStream('order-123')
   *
   * // Read with options
   * const recentEvents = await store.readStream('order-123', {
   *   fromVersion: 5,
   *   limit: 10,
   *   reverse: true,
   * })
   * ```
   */
  readStream(streamId: string, options?: ReadStreamOptions): Promise<StreamDomainEvent[]>

  /**
   * Get the current version of a stream.
   *
   * @param streamId - Stream identifier
   * @returns Current version (0 if stream doesn't exist)
   *
   * @example
   * ```typescript
   * const version = await store.getStreamVersion('order-123')
   * if (version === 0) {
   *   console.log('Stream does not exist')
   * }
   * ```
   */
  getStreamVersion(streamId: string): Promise<number>

  /**
   * Check if a stream exists (has at least one event).
   *
   * @param streamId - Stream identifier
   * @returns true if stream has at least one event
   *
   * @example
   * ```typescript
   * if (await store.streamExists('order-123')) {
   *   const events = await store.readStream('order-123')
   * }
   * ```
   */
  streamExists(streamId: string): Promise<boolean>
}

// ============================================================================
// ConcurrencyError
// ============================================================================

/**
 * Error thrown when optimistic concurrency check fails.
 *
 * This error indicates that the stream was modified between reading
 * the expected version and attempting to append. The client should
 * reload the stream state and retry the operation.
 *
 * @example
 * ```typescript
 * try {
 *   await store.append({ streamId, type, payload, expectedVersion: 5 })
 * } catch (error) {
 *   if (error instanceof ConcurrencyError) {
 *     console.log(`Stream ${error.streamId} was modified`)
 *     console.log(`Expected: ${error.expectedVersion}, Actual: ${error.actualVersion}`)
 *     // Reload and retry
 *   }
 * }
 * ```
 */
export class ConcurrencyError extends Error {
  /** Name of the error class */
  readonly name = 'ConcurrencyError'

  /**
   * Create a new ConcurrencyError.
   *
   * @param streamId - The stream where the conflict occurred
   * @param expectedVersion - The version that was expected
   * @param actualVersion - The actual current version of the stream
   */
  constructor(
    public readonly streamId: string,
    public readonly expectedVersion: number,
    public readonly actualVersion: number
  ) {
    super(
      `Concurrency conflict on stream '${streamId}': expected version ${expectedVersion}, but actual version is ${actualVersion}`
    )
  }
}

// ============================================================================
// Schema
// ============================================================================

/**
 * SQL schema for the events table.
 *
 * Key features:
 * - UNIQUE(stream_id, version) ensures monotonic versioning per stream
 * - timestamp allows time-based queries
 * - metadata stored as JSON for flexibility
 *
 * @remarks
 * The schema uses IF NOT EXISTS for idempotent creation.
 */
export const EVENT_STORE_SCHEMA_SQL = `
-- Events table for stream-based event sourcing
CREATE TABLE IF NOT EXISTS events (
  id TEXT PRIMARY KEY,
  stream_id TEXT NOT NULL,
  type TEXT NOT NULL,
  version INTEGER NOT NULL,
  timestamp INTEGER NOT NULL,
  payload TEXT NOT NULL,
  metadata TEXT,
  UNIQUE(stream_id, version)
);

-- Index for efficient stream queries
CREATE INDEX IF NOT EXISTS idx_events_stream ON events(stream_id, version);

-- Index for time-based queries
CREATE INDEX IF NOT EXISTS idx_events_timestamp ON events(timestamp);

-- Index for event type queries
CREATE INDEX IF NOT EXISTS idx_events_type ON events(type);
`

// ============================================================================
// Database Row Type
// ============================================================================

/**
 * Internal database row representation.
 * @internal
 */
interface EventRow {
  id: string
  stream_id: string
  type: string
  version: number
  timestamp: number
  payload: string
  metadata: string | null
}

// ============================================================================
// EventStore Implementation
// ============================================================================

/**
 * Event Store implementation using SQL storage.
 *
 * Provides stream-based event sourcing with optimistic concurrency control,
 * customizable serialization, and pluggable ID generation.
 *
 * @implements {IEventStore}
 *
 * @example
 * ```typescript
 * // Basic usage
 * const store = new EventStore(ctx.storage.sql)
 *
 * // With custom options
 * const store = new EventStore(ctx.storage.sql, {
 *   idGenerator: () => ulid(),
 *   serializer: customSerializer,
 * })
 *
 * // Append event to stream
 * const result = await store.append({
 *   streamId: 'order-123',
 *   type: 'OrderCreated',
 *   payload: { customerId: 'cust-456', total: 99.99 },
 *   expectedVersion: 0, // New stream
 * })
 *
 * // Batch append
 * const batchResult = await store.appendBatch({
 *   streamId: 'order-123',
 *   expectedVersion: 1,
 *   events: [
 *     { type: 'ItemAdded', payload: { itemId: 'item-1' } },
 *     { type: 'ItemAdded', payload: { itemId: 'item-2' } },
 *   ],
 * })
 *
 * // Read events from stream
 * const events = await store.readStream('order-123')
 *
 * // Check stream version
 * const version = await store.getStreamVersion('order-123')
 * ```
 */
export class EventStore implements IEventStore {
  /** @internal */
  protected readonly sql: SqlStorage

  /** @internal */
  private schemaInitialized = false

  /** @internal */
  private readonly generateId: IdGenerator

  /** @internal */
  private readonly serializer: EventSerializer

  /** @internal */
  private readonly getTimestamp: () => number

  /**
   * Create a new EventStore instance.
   *
   * @param sql - SQL storage instance (from Durable Object ctx.storage.sql)
   * @param options - Optional configuration for ID generation, serialization, etc.
   */
  constructor(sql: SqlStorage, options?: EventStoreOptions) {
    this.sql = sql
    this.generateId = options?.idGenerator ?? uuidGenerator
    this.serializer = options?.serializer ?? jsonSerializer
    this.getTimestamp = options?.timestampProvider ?? (() => Date.now())
  }

  /**
   * Ensure the events table exists.
   * @internal
   */
  private ensureSchema(): void {
    if (this.schemaInitialized) return

    // Execute schema creation (idempotent via IF NOT EXISTS)
    this.sql.exec(EVENT_STORE_SCHEMA_SQL)
    this.schemaInitialized = true
  }

  /**
   * Append an event to a stream with optimistic concurrency control.
   *
   * @param input - Event data to append
   * @returns The appended event and current stream version
   * @throws {ConcurrencyError} If expectedVersion doesn't match actual version
   */
  async append<T>(input: AppendEventInput<T>): Promise<AppendResult> {
    this.ensureSchema()

    const { streamId, type, payload, expectedVersion, metadata } = input

    // Get current version
    const currentVersion = await this.getStreamVersion(streamId)

    // Check expected version if provided
    if (expectedVersion !== undefined && expectedVersion !== currentVersion) {
      throw new ConcurrencyError(streamId, expectedVersion, currentVersion)
    }

    // Calculate next version
    const nextVersion = currentVersion + 1

    // Generate event ID and timestamp
    const id = this.generateId()
    const timestamp = this.getTimestamp()

    // Serialize payload and metadata
    const payloadJson = this.serializer.serialize(payload)
    const metadataJson = metadata ? this.serializer.serialize(metadata) : null

    // Insert event
    this.sql.exec(
      `INSERT INTO events (id, stream_id, type, version, timestamp, payload, metadata)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      id,
      streamId,
      type,
      nextVersion,
      timestamp,
      payloadJson,
      metadataJson
    )

    // Create event object
    const event: StreamDomainEvent<T> = {
      id,
      streamId,
      type,
      version: nextVersion,
      timestamp,
      payload,
      metadata,
    }

    return {
      event: event as StreamDomainEvent,
      currentVersion: nextVersion,
    }
  }

  /**
   * Append multiple events to a stream atomically.
   *
   * All events are appended with sequential versions starting from
   * currentVersion + 1. If the expectedVersion check fails, no events
   * are appended.
   *
   * @param input - Batch input with stream ID, expected version, and events
   * @returns The appended events and final stream version
   * @throws {ConcurrencyError} If expectedVersion doesn't match actual version
   */
  async appendBatch<T>(input: AppendBatchInput<T>): Promise<AppendBatchResult> {
    this.ensureSchema()

    const { streamId, expectedVersion, events: inputEvents } = input

    // Handle empty batch
    if (inputEvents.length === 0) {
      const currentVersion = await this.getStreamVersion(streamId)
      return { events: [], currentVersion }
    }

    // Get current version
    const currentVersion = await this.getStreamVersion(streamId)

    // Check expected version if provided
    if (expectedVersion !== undefined && expectedVersion !== currentVersion) {
      throw new ConcurrencyError(streamId, expectedVersion, currentVersion)
    }

    const appendedEvents: StreamDomainEvent[] = []
    let version = currentVersion

    // Append each event
    for (const eventInput of inputEvents) {
      version++
      const id = this.generateId()
      const timestamp = this.getTimestamp()

      // Serialize payload and metadata
      const payloadJson = this.serializer.serialize(eventInput.payload)
      const metadataJson = eventInput.metadata ? this.serializer.serialize(eventInput.metadata) : null

      // Insert event
      this.sql.exec(
        `INSERT INTO events (id, stream_id, type, version, timestamp, payload, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        id,
        streamId,
        eventInput.type,
        version,
        timestamp,
        payloadJson,
        metadataJson
      )

      // Create event object
      const event: StreamDomainEvent<T> = {
        id,
        streamId,
        type: eventInput.type,
        version,
        timestamp,
        payload: eventInput.payload as T,
        metadata: eventInput.metadata,
      }

      appendedEvents.push(event as StreamDomainEvent)
    }

    return {
      events: appendedEvents,
      currentVersion: version,
    }
  }

  /**
   * Read events from a stream.
   *
   * @param streamId - Stream identifier
   * @param options - Read options (fromVersion, toVersion, limit, reverse)
   * @returns Array of events in version order (or reverse order if specified)
   */
  async readStream(streamId: string, options?: ReadStreamOptions): Promise<StreamDomainEvent[]> {
    this.ensureSchema()

    const conditions: string[] = ['stream_id = ?']
    const params: unknown[] = [streamId]

    // Add version filters
    if (options?.fromVersion !== undefined) {
      conditions.push('version >= ?')
      params.push(options.fromVersion)
    }

    if (options?.toVersion !== undefined) {
      conditions.push('version <= ?')
      params.push(options.toVersion)
    }

    // Build query
    const orderDirection = options?.reverse ? 'DESC' : 'ASC'
    let query = `SELECT id, stream_id, type, version, timestamp, payload, metadata
                 FROM events
                 WHERE ${conditions.join(' AND ')}
                 ORDER BY version ${orderDirection}`

    if (options?.limit !== undefined) {
      query += ' LIMIT ?'
      params.push(options.limit)
    }

    const rows = this.sql.exec<EventRow>(query, ...params).toArray()

    return rows.map((row) => this.deserializeRow(row))
  }

  /**
   * Get the current version of a stream.
   *
   * @param streamId - Stream identifier
   * @returns Current version (0 if stream doesn't exist)
   */
  async getStreamVersion(streamId: string): Promise<number> {
    this.ensureSchema()

    const result = this.sql
      .exec<{ max_version: number | null }>(
        'SELECT MAX(version) as max_version FROM events WHERE stream_id = ?',
        streamId
      )
      .one()

    return result?.max_version ?? 0
  }

  /**
   * Check if a stream exists.
   *
   * @param streamId - Stream identifier
   * @returns true if stream has at least one event
   */
  async streamExists(streamId: string): Promise<boolean> {
    this.ensureSchema()

    const result = this.sql
      .exec<{ count: number }>('SELECT COUNT(*) as count FROM events WHERE stream_id = ? LIMIT 1', streamId)
      .one()

    return (result?.count ?? 0) > 0
  }

  /**
   * Deserialize a database row to a StreamDomainEvent.
   * @internal
   */
  private deserializeRow(row: EventRow): StreamDomainEvent {
    return {
      id: row.id,
      streamId: row.stream_id,
      type: row.type,
      version: row.version,
      timestamp: row.timestamp,
      payload: this.serializer.deserialize(row.payload),
      metadata: row.metadata ? (this.serializer.deserialize(row.metadata) as EventMetadata) : undefined,
    }
  }
}
