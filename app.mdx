---
$type: Worker
$id: app
name: app
main: src/index.ts
compatibility_date: "2025-07-08"
account_id: b6641681fe423910342b9ffa1364c76d

observability:
  enabled: true

placement:
  mode: smart

services:
  - binding: DB
    service: db
  - binding: AUTH
    service: auth

d1_databases:
  - binding: D1
    database_name: admin
    database_id: 81e7b9cb-3705-47be-8ad5-942877a55d64

r2_buckets:
  - binding: MEDIA
    bucket_name: admin-media

vars:
  PAYLOAD_URL: https://admin-payload.pages.dev
---

# App Service - Admin CMS Worker

Admin CMS worker that proxies requests to Payload CMS deployed on Cloudflare Pages.

## Overview

The App service provides a seamless proxy layer between the gateway and Payload CMS, enabling:
- **HTTP Proxy** - Forwards requests to Payload CMS Pages deployment
- **RPC Interface** - Service-to-service communication
- **Health Checks** - Service health monitoring
- **Session Management** - Handles authentication state
- **File Upload Handling** - Manages media uploads to R2

## Features

- ✅ **Smart Placement** - Cloudflare optimizes worker placement globally
- ✅ **Service Bindings** - Direct RPC calls to DB and AUTH services
- ✅ **D1 Database** - Dedicated database for Payload CMS
- ✅ **R2 Storage** - Media file storage and delivery
- ✅ **Proxy Pattern** - Transparent request forwarding to Pages deployment
- ✅ **CORS Support** - Cross-origin resource sharing enabled
- ✅ **Error Handling** - Graceful fallback for proxy failures
- ✅ **Observability** - Built-in monitoring and logging

## Architecture

```
admin.do → gateway → app worker → Payload Pages (admin-payload.pages.dev)
                           ↓
                    ┌──────┴──────┐
                    ↓             ↓
              DB Service    AUTH Service
                    ↓             ↓
                  D1 DB      R2 Bucket
```

**Service Dependencies:**
- **Database Service** (binding: `DB`) - Data persistence via RPC
- **Auth Service** (binding: `AUTH`) - Authentication and authorization
- **D1 Database** (binding: `D1`) - Payload CMS database
- **R2 Bucket** (binding: `MEDIA`) - Media file storage

**Data Flow:**
1. Client sends request to `admin.do`
2. Gateway routes to app worker
3. App worker validates authentication via AUTH service
4. Request proxied to Payload Pages deployment
5. Payload renders admin UI or processes API request
6. Response returned to client

## API

### RPC Methods

The service exports an `AppService` class that can be called via RPC:

```ts
// Get app health status
const health = await env.APP.health()
// { status: 'healthy', timestamp: '2025-10-04T00:00:00Z' }

// All other operations go through HTTP interface
```

### HTTP Endpoints

#### `GET /health`

Check service health status.

**Response:**
```json
{
  "status": "healthy",
  "timestamp": "2025-10-04T00:00:00Z",
  "service": "app"
}
```

#### `* /*` (All Other Routes)

All non-health requests are proxied to Payload CMS Pages deployment.

**Supported Methods:**
- GET, POST, PUT, PATCH, DELETE
- HEAD, OPTIONS

**Payload Routes (Examples):**
- `/admin` - Admin panel UI
- `/api/users` - User management API
- `/api/media` - Media management API
- `/api/collections/*` - Dynamic collection APIs

## Configuration

### Environment Variables

```bash
# Payload CMS Pages URL (optional, defaults to admin-payload.pages.dev)
PAYLOAD_URL=https://admin-payload.pages.dev
```

### Secrets

```bash
# Payload secret key (required)
wrangler secret put PAYLOAD_SECRET
```

### Service Bindings

- **DB** - Database service for data access
- **AUTH** - Auth service for authentication

### D1 Database

```bash
# Create D1 database
wrangler d1 create admin

# Update wrangler.jsonc with database_id
# "database_id": "actual-d1-database-id"

# Run Payload migrations
cd ../../projects/app
NODE_ENV=production PAYLOAD_SECRET=your-secret pnpm payload migrate
```

### R2 Bucket

```bash
# Create R2 bucket for media storage
wrangler r2 bucket create admin-media
```

## Development

```bash
# Install dependencies
pnpm install

# Run dev server
pnpm dev

# Type check
pnpm typecheck

# Run tests
pnpm test

# Build
pnpm build
```

## Deployment

```bash
# Deploy to production
pnpm deploy

# Or deploy directly with wrangler
wrangler deploy
```

### Deployment Order

The app service should be deployed after its dependencies:

1. **db** service - Must be deployed first
2. **auth** service - Must be deployed second
3. **app** service - Can deploy once dependencies are ready

## Usage Examples

### HTTP Proxy

All requests are proxied to Payload CMS:

```bash
# Health check (handled by worker)
curl https://admin.do/health

# Payload admin panel
curl https://admin.do/admin

# Payload API endpoints
curl https://admin.do/api/users
curl https://admin.do/api/media

# Custom collections
curl https://admin.do/api/posts
curl https://admin.do/api/pages
```

### RPC Interface

```ts
// Call from other services
const health = await env.APP.health()
console.log(health)
// { status: 'healthy', timestamp: '2025-10-04T00:00:00Z' }
```

## Integration with Payload CMS

### Payload Deployment

The Payload CMS app is deployed separately to Cloudflare Pages:

```bash
cd ../../projects/app
pnpm build
pnpm deploy
```

### Domain Routing

The worker expects Payload to be deployed at:
- **Production:** `https://admin-payload.pages.dev`
- **Custom domain:** Set `PAYLOAD_URL` environment variable

### Authentication Flow

```
1. User visits admin.do/admin
2. Gateway checks auth (middleware)
3. If not authenticated, redirect to auth.services.do/login
4. After login, redirect back to admin.do/admin
5. Gateway forwards to app worker
6. App worker proxies to Payload Pages
7. Payload renders admin UI
```

### Data Storage

- **D1 Database** - Stores all CMS data (users, collections, media metadata)
- **R2 Bucket** - Stores uploaded media files (images, videos, documents)

### API Integration

Other services can interact with Payload via the app worker:

```ts
// Example: Create a blog post via Payload API
const response = await fetch('https://admin.do/api/posts', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${apiKey}`
  },
  body: JSON.stringify({
    title: 'New Blog Post',
    content: 'Post content...',
    status: 'published'
  })
})

const post = await response.json()
```

## Error Handling

The service handles various error scenarios:

### Proxy Errors

When Payload Pages is unreachable:

```json
{
  "error": "Proxy error",
  "message": "Network connection failed",
  "service": "app"
}
```

**HTTP Status:** 502 Bad Gateway

### Configuration Errors

Missing or invalid configuration:

```bash
# Check PAYLOAD_URL is set
wrangler secret list

# Verify D1 database exists
wrangler d1 list

# Verify R2 bucket exists
wrangler r2 bucket list
```

## Monitoring

The service supports observability through:

- **Health Endpoint** - `/health` for uptime checks
- **Cloudflare Analytics** - Request metrics and errors
- **Workers Logs** - Console output via `wrangler tail`

```bash
# Tail logs in real-time
wrangler tail app

# Filter for errors only
wrangler tail app --status error
```

## Performance

### Caching Strategy

- Static assets cached at edge via Cloudflare CDN
- API responses cached according to Cache-Control headers
- Media files served directly from R2 with CDN caching

### Smart Placement

Cloudflare automatically places the worker:
- Near database for database-heavy operations
- Near users for latency-sensitive operations
- Optimized based on real-time traffic patterns

## Security

### Authentication

All requests authenticated via gateway middleware:
- Session cookies validated
- API keys verified
- JWT tokens checked

### Authorization

Payload CMS handles authorization:
- Role-based access control (RBAC)
- Collection-level permissions
- Field-level access control

### Data Protection

- **Secrets** - Never exposed in responses
- **CORS** - Configured per-origin
- **Rate Limiting** - Enforced by gateway
- **Input Validation** - Handled by Payload

## Testing

### Unit Tests

Test the RPC interface and HTTP proxy:

```ts
import { describe, it, expect, beforeEach } from 'vitest'
import { AppService } from './index'

describe('AppService', () => {
  let service: AppService
  let env: any

  beforeEach(() => {
    env = {
      DB: mockDbService,
      AUTH: mockAuthService,
      D1: mockD1Database,
      MEDIA: mockR2Bucket,
      PAYLOAD_SECRET: 'test-secret',
      PAYLOAD_URL: 'https://test-payload.pages.dev'
    }
    service = new AppService({} as any, env)
  })

  it('should return health status', async () => {
    const result = await service.health()
    expect(result.status).toBe('healthy')
    expect(result.timestamp).toBeDefined()
  })
})
```

### Integration Tests

Test proxy behavior:

```ts
describe('App HTTP Proxy', () => {
  it('should proxy GET requests to Payload', async () => {
    const response = await app.request('/api/users', {}, env)
    expect(response.status).toBe(200)
  })

  it('should proxy POST requests to Payload', async () => {
    const response = await app.request('/api/posts', {
      method: 'POST',
      body: JSON.stringify({ title: 'Test' }),
      headers: { 'Content-Type': 'application/json' }
    }, env)
    expect(response.status).toBe(201)
  })

  it('should handle Payload unavailable', async () => {
    // Mock Payload being down
    const response = await app.request('/admin', {}, env)
    expect(response.status).toBe(502)
  })
})
```

### E2E Tests

Test complete authentication flow:

```bash
# Login flow
curl -X POST https://admin.do/api/users/login \
  -d '{"email":"admin@test.com","password":"test123"}'

# Access admin panel
curl https://admin.do/admin \
  -H "Cookie: payload-token=..."

# API request
curl https://admin.do/api/posts \
  -H "Authorization: Bearer $TOKEN"
```

## Troubleshooting

### Payload Not Loading

**Symptom:** 502 errors when accessing admin panel

**Solutions:**
1. Check PAYLOAD_URL is set correctly
2. Verify Payload Pages is deployed and accessible
3. Check wrangler logs for proxy errors

```bash
wrangler tail app --status error
```

### Authentication Issues

**Symptom:** Redirected to login repeatedly

**Solutions:**
1. Check AUTH service is running
2. Verify session cookies are set correctly
3. Check gateway middleware configuration

### Database Connection Errors

**Symptom:** DB errors in Payload admin

**Solutions:**
1. Verify D1 database exists and is accessible
2. Run Payload migrations if needed
3. Check DB service binding is configured

```bash
# List D1 databases
wrangler d1 list

# Run migrations
cd ../../projects/app
pnpm payload migrate
```

### Media Upload Failures

**Symptom:** File uploads fail with 500 errors

**Solutions:**
1. Verify R2 bucket exists
2. Check MEDIA binding is configured
3. Ensure Payload has R2 adapter configured

```bash
# List R2 buckets
wrangler r2 bucket list

# Test R2 access
wrangler r2 object get admin-media test.txt
```

## Related Services

- **Payload CMS** - `projects/app/` - Full CMS application
- **Gateway** - `workers/gateway/` - Routes admin.do to this worker
- **Auth** - `workers/auth/` - WorkOS authentication
- **DB** - `workers/db/` - Database access

## Documentation

- [Payload CMS Docs](https://payloadcms.com/docs)
- [Cloudflare Workers](https://developers.cloudflare.com/workers)
- [Cloudflare Pages](https://developers.cloudflare.com/pages)
- [D1 Database](https://developers.cloudflare.com/d1)
- [R2 Storage](https://developers.cloudflare.com/r2)

## Implementation

### Type Definitions

```typescript
/**
 * Type definitions for App Service
 */

export interface AppEnv {
  // Service bindings
  DB: any // Database service
  AUTH: any // Auth service

  // D1 database (for Payload CMS)
  D1: D1Database

  // R2 bucket (for media storage)
  MEDIA: R2Bucket

  // Environment variables
  PAYLOAD_SECRET: string
  PAYLOAD_URL?: string // Optional: custom Payload Pages URL
}

export interface HealthResponse {
  status: string
  timestamp: string
}

export interface ProxyError {
  error: string
  message: string
  service: string
}
```

### RPC Service

```typescript
/**
 * App Service - Admin CMS Worker
 *
 * Proxies requests to Payload CMS deployed on Cloudflare Pages
 * Provides RPC interface for service-to-service calls
 *
 * Features:
 * - Proxies to Payload CMS Pages deployment
 * - Session management
 * - File upload handling
 * - Database access via service bindings
 *
 * Interfaces:
 * - RPC (WorkerEntrypoint) for service-to-service calls
 * - HTTP (Hono) for REST API proxy
 */

import { WorkerEntrypoint } from 'cloudflare:workers'
import { Hono } from 'hono'
import { cors } from 'hono/cors'

/**
 * App Service RPC Interface
 */
export class AppService extends WorkerEntrypoint<AppEnv> {
  /**
   * Handle HTTP requests via Hono app
   */
  fetch(request: Request): Response | Promise<Response> {
    return app.fetch(request, this.env, this.ctx)
  }

  /**
   * Get app health status
   */
  async health(): Promise<HealthResponse> {
    return {
      status: 'healthy',
      timestamp: new Date().toISOString(),
    }
  }
}
```

### HTTP Interface

```typescript
// ==================== HTTP Interface ====================

type HonoEnv = {
  Bindings: AppEnv
}

const app = new Hono<HonoEnv>()

// Global CORS middleware
app.use('*', cors())

// Health check endpoint
app.get('/health', c => {
  return c.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: 'app',
  })
})

// Proxy all other requests to Payload CMS (deployed via Pages)
app.all('*', async c => {
  const url = new URL(c.req.url)

  // Determine Payload URL (default or custom)
  const payloadBaseUrl = c.env.PAYLOAD_URL || 'https://admin-payload.pages.dev'
  const payloadUrl = new URL(url.pathname + url.search, payloadBaseUrl)

  try {
    // Forward request to Payload Pages deployment
    const response = await fetch(payloadUrl, {
      method: c.req.method,
      headers: c.req.raw.headers,
      body: c.req.method !== 'GET' && c.req.method !== 'HEAD' ? c.req.raw.body : undefined,
    })

    // Return response from Payload
    return new Response(response.body, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
    })
  } catch (error) {
    console.error('[App Worker] Error proxying to Payload:', error)
    return c.json(
      {
        error: 'Proxy error',
        message: error instanceof Error ? error.message : 'Unknown error',
        service: 'app',
      },
      { status: 502 }
    )
  }
})
```

### Worker Export

```typescript
// ==================== Worker Export ====================

export default {
  fetch: app.fetch,
}
```

## Changelog

### v1.0.0 (2025-10-04)

- ✅ Initial release
- ✅ HTTP proxy to Payload Pages
- ✅ RPC interface with health check
- ✅ Service bindings (DB, AUTH)
- ✅ D1 database integration
- ✅ R2 media storage
- ✅ CORS support
- ✅ Error handling
- ✅ Smart placement

---

**Status:** Ready for deployment
**Dependencies:** DB service, AUTH service, Payload Pages deployment
**Domain:** admin.do
**Last Updated:** 2025-10-04
